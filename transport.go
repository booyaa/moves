package moves

import (
	"bytes"
	"encoding/json"
	"errors"
	"net/http"
	"net/url"
	"time"
)

// Transport implements http.RoundTripper. When configured, it can be
// used to make authenticated HTTP requests.
type Transport struct {
	// Key is the identifier string generated by the API for the handshake.
	// The key can be treated as a username.
	Key string

	// Secret is the unique token generated for signing requests.
	// The secret must be kept private.
	Secret string

	// CallbackURI is an absolute URI back to which the server will redirect the
	// resource owner when the Authorization step is completed. If omitted, the
	// default callback URI is used.
	CallbackURI string

	// Token contains an end-user's tokens.
	// This may be a set of temporary credentials.
	Token *Token

	// TokenCache allows tokens to be cached for subsequent requests.
	TokenCache Cache

	// Transport is the HTTP transport to use when making requests.
	// It will default to http.DefaultTransport if nil.
	// It should never be a moves.Transport.
	Transport http.RoundTripper
}

// DefaultTransport implements http.RoundTripper. With a valid token, it
// can be used to make authenticated HTTP requests.
type DefaultTransport struct {
	Token string
}

// AuthorizationURI is an absolute URI used to generate a code that
// can in turn be used to request an access token.
const AuthorizationURI = "https://api.moves-app.com/oauth/v1/authorize"

// ExchangeURI is an absolute URI used to request a set of token
// credentials using the authorization code.
const ExchangeURI = "https://api.moves-app.com/oauth/v1/access_token"

var (
	ErrNoToken        = errors.New("moves: token is nil")
	ErrNoRefreshToken = errors.New("moves: refresh token is empty")
)

// AuthCodeURL returns a URL that the end-user should be redirected to,
// so that they may obtain an authorization code.
func (t *Transport) AuthCodeURL(state string) string {
	auth, err := url.Parse(AuthorizationURI)
	if err != nil {
		panic("AuthorizationURI malformed: " + err.Error())
	}

	q := url.Values{
		"response_type": {"code"},
		"client_id":     {t.Key},
		"scope":         {"activity location"},
		"state":         {state},
	}

	if t.CallbackURI != "" {
		q.Add("redirect_uri", t.CallbackURI)
	}

	if auth.RawQuery == "" {
		auth.RawQuery = q.Encode()
	} else {
		auth.RawQuery += "&" + q.Encode()
	}

	return auth.String()
}

// Exchange takes a code and gets an access Token from the remote server.
func (t *Transport) Exchange(code string) (*Token, error) {
	if t.Token == nil && t.TokenCache != nil {
		t.Token, _ = t.TokenCache.Token()
	}

	if t.Token == nil {
		t.Token = &Token{}
	}

	q := url.Values{
		"grant_type":    {"authorization_code"},
		"code":          {code},
		"client_id":     {t.Key},
		"client_secret": {t.Secret},
	}

	if t.CallbackURI != "" {
		q.Add("redirect_uri", t.CallbackURI)
	}

	err := t.update(q)
	if err != nil {
		return nil, err
	}

	if t.TokenCache != nil {
		return t.Token, t.TokenCache.PutToken(t.Token)
	}

	return t.Token, nil
}

// Refresh renews the Transport's token using its refresh token.
func (t *Transport) Refresh() error {
	if t.Token == nil {
		return ErrNoToken
	}

	if t.Token.Refresh == "" {
		return ErrNoRefreshToken
	}

	q := url.Values{
		"grant_type":    {"refresh_token"},
		"refresh_token": {t.Token.Refresh},
		"client_id":     {t.Key},
		"client_secret": {t.Secret},
	}

	err := t.update(q)
	if err != nil {
		return err
	}

	if t.TokenCache != nil {
		return t.TokenCache.PutToken(t.Token)
	}

	return nil
}

// RoundTrip executes a single HTTP transaction using the Transport's Token as
// authorization headers.
//
// This method will attempt to renew the Token if it has expired and may return
// an error related to that Token renewal before attempting the client request.
// If the Token cannot be renewed a non-nil os.Error value will be returned.
// If the Token is invalid callers should expect HTTP-level errors,
// as indicated by the Response's StatusCode.
func (t *Transport) RoundTrip(req *http.Request) (*http.Response, error) {
	if t.Token == nil {
		if t.TokenCache == nil {
			return nil, ErrNoToken
		}

		var err error
		t.Token, err = t.TokenCache.Token()
		if err != nil {
			return nil, err
		}
	}

	if t.Token.Expired() {
		err := t.Refresh()
		if err != nil {
			return nil, err
		}
	}

	// This is so that we don't modify the original request as specified
	// in the documentation for http.RoundTripper.
	req = cloneRequest(req)
	req.Header.Set("Authorization", "Bearer "+t.Token.Access)

	return t.transport().RoundTrip(req)
}

// Client returns a new Client that can make authenticated requests.
func (t *Transport) Client() *Client {
	return &Client{
		Client:  &http.Client{Transport: t},
		BaseURI: BaseURI,
	}
}

// transport returns the configured Transport, or the http.DefaultTransport.
func (t *Transport) transport() http.RoundTripper {
	if t.Transport != nil {
		return t.Transport
	}

	return http.DefaultTransport
}

// update requests a new access token.
func (t *Transport) update(q url.Values) error {
	update, err := url.Parse(ExchangeURI)
	if err != nil {
		panic("ExchangeURI malformed: " + err.Error())
	}

	if update.RawQuery == "" {
		update.RawQuery = q.Encode()
	} else {
		update.RawQuery += "&" + q.Encode()
	}

	// Empty JSON body so that we don't get HTML back on error.
	body := bytes.NewReader([]byte("{}"))
	resp, err := http.Post(update.String(), "application/json", body)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		var accessTokenError struct {
			Code string `json:"error"`
		}

		err = json.NewDecoder(resp.Body).Decode(&accessTokenError)
		if err != nil {
			return err
		}

		return errors.New(accessTokenError.Code)
	}

	var b struct {
		AccessToken  string        `json:"access_token"`
		RefreshToken string        `json:"refresh_token"`
		ExpiresIn    time.Duration `json:"expires_in"`
		UserId       uint64        `json:"user_id"`
	}

	err = json.NewDecoder(resp.Body).Decode(&b)
	if err != nil {
		return err
	}

	t.Token.Access = b.AccessToken
	t.Token.UserId = b.UserId

	if b.RefreshToken != "" {
		t.Token.Refresh = b.RefreshToken
	}

	// The JSON decoder treats ExpiresIn as nanoseconds instead of seconds.
	b.ExpiresIn *= time.Second
	if b.ExpiresIn == 0 {
		t.Token.Expiry = time.Time{}
	} else {
		t.Token.Expiry = time.Now().Add(b.ExpiresIn).UTC()
	}

	return nil
}

// RoundTrip executes a single HTTP transaction using the Transport's Token as
// authorization headers.
func (t *DefaultTransport) RoundTrip(req *http.Request) (*http.Response, error) {
	// This is so that we don't modify the original request as specified
	// in the documentation for http.RoundTripper.
	req = cloneRequest(req)
	req.Header.Set("Authorization", "Bearer "+t.Token)

	return http.DefaultTransport.RoundTrip(req)
}

// cloneRequest returns a copy of the given request.
func cloneRequest(r *http.Request) *http.Request {
	// shallow copy of the struct
	r2 := new(http.Request)
	*r2 = *r
	// deep copy of the Header
	r2.Header = make(http.Header)
	for k, s := range r.Header {
		r2.Header[k] = s
	}
	return r2
}
